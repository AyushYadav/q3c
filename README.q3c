				Q3C

    Author: Sergey Koposov, Sternberg Astronomical Institute, 
                            Max Planck Institute for Astronomy,
							Institute of Astronomy, Cambridge
    Email: koposov@ast.cam.ac.uk
    http://lnfm1.sai.msu.ru/~math

    Idea and realization by Sergey Koposov.
    General formulation and testing by Oleg Bartunov 
                     (Sternberg Astronomical Institute, Moscow University).

---------------------------------------------------------------------
			ABOUT

To read more about the whole Q3C scheme, look into the paper on Q3C from the
ADASS proceedings. The URL of the paper: 
http://lnfm1.sai.msu.ru/~math/docs/adass_proceedings2005.pdf
The reference:
\bibitem[Koposov \& Bartunov(2006)]{2006ASPC..351..735K} Koposov, S., \& 
Bartunov, O.\ 2006, Astronomical Society of the Pacific Conference Series, 
351, 735
If you use Q3C you are kindly asked to cite this paper. Also, I 
(Sergey Koposov) would be also happy to hear about any usage of Q3C.

----------------------------------------------------------------------
			PREREQUISITES

To work with Q3C you need to have PostgreSQL database installed (version 8.1
or later). For the installation of PostgreSQL refer to the PostgreSQL manual.

----------------------------------------------------------------------

			INSTALLATION

1) make 
2) make install
3) Do "\i q3c.sql" in PostgreSQL shell

Note: To successfully compile Q3C you need to have the program called 
pg_config in your PATH, or if it is not, you can put the Q3C directory 
in the contrib subdirectory of PostgreSQL sources and execute
"make NO_PGXS=1" instead of simple "make".

After the installation you will have several new functions in PostgreSQL.
All names of these functions start with the "q3c_" prefix.

-----------------------------------------------------------------------

           FUNCTIONS

All the angles used by q3c are always in degrees. 
The functions installed by Q3C are: 

q3c_ang2ipix(ra, dec) -- returns the ipix value at ra and dec

q3c_dist(ra1, dec1, ra2, dec2) -- returns the distance in degrees between 
(ra1,dec1) and (ra2,dec2)

q3c_join(ra1, dec1, ra2, dec2, radius)  -- returns true if (ra1, dec1)
  is within radius spherical distance of (ra2, dec2). It should be used when 
the index on q3c_ang2ipix(ra2,dec2) is created.

q3c_ellipse_join(ra1, dec1, ra2, dec2, major, ratio, pa) -- like
  q3c_join, except (ra1, dec1) have to be within an ellipse with
  major axis major, the axis ratio ratio and the position angle pa
  (from north through east)

q3c_radial_query(ra, dec, center_ra, center_dec, radius) -- returns
  true if ra, dec is within radius degrees of center_ra, center_dec. This
  function should be used if when the index on q3c_ang2ipix(ra,dec) is created)

q3c_ellipse_query(ra, dec, center_ra, center_dec, maj_ax,
						axis_ratio, PA ) -- returns
  true if ra, dec is within the ellipse from center_ra, center_dec.
  The ellipse is specified by major axis, axis ratio and positional angle.
  function should be used if when the index on q3c_ang2ipix(ra,dec) is created)

q3c_poly_query(ra, dec, poly) -- returns true if ra, dec is within
  the postgresql polygon poly.

q3c_ipix2ang(ipix) -- returns a 2-array of (ra,dec) corresponding to ipix.

q3c_pixarea(ipix, bits) -- returns the area corresponding to ipix at level
	bits (1 is smallest, 30 is the cube face) in steradians.

q3c_ipixcenter(ra, dec, bits) -- the function returning the ipix value of the
	pixel center of certain depth covering the specified (ra,dec)

---------------------------------------------------------------------

		PREPARATION OF TABLES before using Q3C

To begin use Q3C for searches and cross-matches you should create the indexes
on the tables.

Suppose you have the table called "mytable" with "ra" and "dec" columns 
(right ascension and declination in degrees).

First, you should create the spatial index, using the following command:

my_db# CREATE INDEX q3c_mytable_idx ON mytable (q3c_ang2ipix(ra, dec)); 

After that it is better to cluster that table using that index. 
Clustering procedure is the procedure of ordering the data on the disk
according to the Q3C spatial index values. If the data is already loaded
in the Database ordered by some spherical zones or something similar,
the clustering step can be ommited (although still recommended). The
clustering step may take a while if your dataset is large

my_db# CLUSTER q3c_mytable_idx ON mytable;

Now you should do the last step -- analyze your table:

my_db# ANALYZE mytable;

Now the power of Q3C is available to you!!! :) 

-----------------------------------------------------------------

			EXAMPLES OF USAGE

x) The cone search (the query of all objects within the circular region of
the sky):

To query all objects lying within radius0=0.1 deg from ra0 = 11deg, 
dec0 = 12deg in table mytable you should do:
 
my_db# SELECT * FROM mytable WHERE q3c_radial_query(ra, dec, 11, 12, 0.1);

The order of arguments is important here, so that the column names would come 
first, and the location where you search after, otherwise the index won't be used.

x) The ellipse search: search for objects within the ellipse from a given point:

my_db=# select * from mytable WHERE
	q3c_ellipse_query(ra, dec, 10, 20, 1, 0.5 ,10);

returns the objects which are within the ellipse with the center at (ra,dec)=(10,20)
major axis of 1 degree, axis ratio of 0.5  and positional angle of 10 degrees.

x) The polygonal query (the query of the objects which lie inside the region
bounded by the polygon on the sphere)

To query the objects in the polygon ((0,0),(2,0),(2,1),(0,1)) )
(this is the spherical polygon with following vertices:
(ra=0, dec=0) ; (ra=2, dec=0); (ra=2, dec=1); (ra=0, dec=1)):

mytable# SELECT * FROM mytable WHERE
		q3c_poly_query(ra, dec, '{0, 0, 2, 0, 2, 1, 0, 1}');

x) The ellipse query (the query of objects which lie inside an ellipse, with
	ra=10, dec=20, major axis=1deg, axis ratio=0.5 and positional angle=10deg)

my_db=# select * from mytable WHERE
	q3c_ellipse_query(ra, dec, 10, 20, 1, 0.5 ,10);


x) The positional cross-match of the tables:

Lets Assume that we have a huge table "table2" with ra and dec columns and
an already created Q3C index and the smaller table "table1" with ra and dec 
columns.

Now, if we want to cross-match the tables "table1" and "table2" by position 
with the crossmatch radius of 0.001 degrees, we should do:

mytable# SELECT * FROM table1 AS a, table2 AS b WHERE
		q3c_join(a.ra, a.dec, b.ra, b.dec, 0.001);

The order of arguments is important again, because it determines whether an
index is going to be used or not. The ra,dec columns from the table with the 
index should go after the ra,dec columns from the table without the index.

If every object in the table1 have his own error circle (like with X-ray data
for example) (suppose that the radius of that circle is the column "err"),
then you can run the query:

mytable# SELECT * FROM table1 AS a, table2 AS b WHERE
		q3c_join(a.ra, a.dec, b.ra, b.dec, a.err);

x) The positional cross-match of the tables with the ellipse error-area:
(for example if you want to find all the objects from one catalogue which lies
inside the elliptical bodies of the galaxies from the second catalogue)

It is possible to do the join when the error area of each record of the 
catalogue is an ellipse. Then you can do the query like this

mytable# SELECT * FROM table1 AS a, table2 AS b WHERE
		q3c_ellipse_join(a.ra, a.dec, b.ra, b.dec, a.maj_ax
		a.axis_ratio, a.PA);

where axis_ratio is the column with axis ratio of the ellipses and PA is the 
column with the positional angles of them, and maj_ax is the column with major
axises of those ellipses.


x) The density estimation of your objects using pixelation depth of 25:

mytable# SELECT (q3c_ipix2ang(i))[1] as ra ,(q3c_ipix2ang(i))[2] as dec ,c,
				q3c_pixarea(i,25) as area from 
					(select q3c_ipixcenter(ra,dec, 25) as i, count(*) as c from
						mytable group by i) as x;

	returns the list of ra,dec of the Q3C pixel center, number of objects
	within a given pixel, and pixel area. If you use that query you should
	keep in mind that Q3C doesn't have the property of uniform pixel areas (as 
	opposed to HEALPIX).

