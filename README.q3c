				Q3C

    Author: Sergey Koposov, Sternberg Astronomical Institute, 
                            Max Planck Institute for Astronomy
    Email: math@sai.msu.ru 
    http://lnfm1.sai.msu.ru/~math

    Idea and realization by Sergey Koposov.
    General formulation and testing by Oleg Bartunov 
                     (Sternberg Astronomical Institute, Moscow University).

---------------------------------------------------------------------
			ABOUT

To read more about the whole Q3C scheme, look into the paper on Q3C from the
ADASS proceedings. The URL of the paper: 
http://lnfm1.sai.msu.ru/~math/docs/adass_proceedings2005.pdf
The reference:
\bibitem[Koposov \& Bartunov(2006)]{2006ASPC..351..735K} Koposov, S., \& 
Bartunov, O.\ 2006, Astronomical Society of the Pacific Conference Series, 
351, 735
If you will use Q3C you are kindly asked to cite this paper. Also, I 
(Sergey Koposov) will be also happy to hear about any usage of Q3C.

----------------------------------------------------------------------
			PREREQUISITES

To work successfully with Q3C you need to have the version of PostgreSQL 8.1
and later. To successfully install PostgreSQL you should be root or owner 
of the Postgres installation. 

----------------------------------------------------------------------

			INSTALLATION

1) make 
2) make install
3) Do "\i q3c.sql" in postgres 

Note: To successfully compile you need to have the program pg_config in 
your path, or if not, you can put the directory with q3c in the contrib
subdirectory of Postgres sources and do 
"make NO_PGXS=1" instead of make.

After that installation you will have 
several new functions in postgres with the q3c_ prefix.

The useful ones are: 

q3c_ang2ipix(ra, dec) -- returns the ipix value at ra and dec in degrees

q3c_join(ra1, dec1, ra2, dec2, radius)  -- returns true if (ra1, dec1)
  is within radius degrees of (ra2, dec2).

q3c_ellipse_join(ra1, dec1, ra2, dec2, major, ratio, pa) -- like
  q3c_join, except (ra1, dec2) have to be within an ellipse with
  major axis major, the axis ratio ratio and the position angle pa
  (XXX counted east over north??? XXX)

q3c_radial_query(ra, dec, center_ra, center_dec, radius) -- returns
  true if ra, dec is within radius degrees of center_ra, center_dec (use
  this for cone searches).

q3c_poly_query(ra, dec, poly) -- returns true if ra, dec is within
  the postgresql polygon poly.

q3c_ipix2ang(ipix) -- returns a 2-array of (ra,dec) corresponding to ipix.

q3c_pixarea(ipix, bits) -- returns the area corresponding to ipix at level
	bits (1 is smallest, 30 is the cube face) in steradians.

q3c_ipixcenter(ra, dec, bits) -- the function returning the ipix value of the
	pixel center of certain depth covering the specified (ra,dec)

---------------------------------------------------------------------

		PREPARATION OF TABLES before using Q3C

To begin use Q3C for searches and cross-matches you should create the indexes
on the tables.

If you have the table "mytable" with "ra" and "dec" columns (right ascension 
and declination in degrees).

You should first create the spatial index:

my_db# CREATE INDEX q3c_mytable_idx ON mytable (q3c_ang2ipix(ra, dec)); 

And after that it is better to cluster that table using that index. 
(Clustering procedure is mainly order the data on the disk according to the 
Q3C spatial index values). If the data is already loaded in the DB ordered by 
some spherical zones or something similar, the clustering step can be ommited.

my_db# CLUSTER q3c_mytable_idx ON my_table;

Now you should do the last step -- analyze your table:

my_db# ANALYZE my_table;

Now the power of Q3C is available for you!!! :) 

-----------------------------------------------------------------

			EXAMPLES OF USAGE

x) The cone search: (the query in the circular region on the sky)

To perform the query around ra0 = 11deg and dec0 = 12deg with radius0 = 0.1deg 
from the table mytable you can do:
 
my_db# SELECT * FROM mytable WHERE q3c_radial_query(ra, dec, 11, 12, 0.1);

x) The polygonal query (the query of the objects which lie inside the region
bounded by the polygon on the sphere)

To query the objects in the polygon ((0,0),(2,0),(2,1),(0,1)) )
(this is the spherical polygon with following vertices:
(ra=0, dec=0) ; (ra=2, dec=0); (ra=2, dec=1); (ra=0, dec=1)):

my_table# SELECT * FROM mytable WHERE
		q3c_poly_query(ra, dec, '{0, 0, 2, 0, 2, 1, 0, 1}');

x) The ellipse query (the query of object which lie inside an ellipse, with
	ra=10, dec=20, major axis=1deg, axis ratio=0.5 and positional angle=10deg)

my_db=# select * from mytable WHERE
	q3c_ellipse_query(ra, dec, 10, 20, 1, 0.5 ,10);


x) The positional cross-match of the tables:

Assuming that we have a huge table "table2" with already created ipix index
and with ra and dec columns and the smaller one "table1" with ra and dec 
columns.

If we want now to cross-match the tables "table1" and "table2" with error 
circle with the size 0.001 degrees, we do:

my_table# SELECT * FROM table1 AS a, table2 AS b WHERE
		q3c_join(a.ra, a.dec, b.ra, b.dec, 0.001) 

If every object in the table1 have his own error circle (like with X-ray data
for example) (suppose that the radius of that circle is the column "err"),
then you can run the query:

my_table# SELECT * FROM table1 AS a, table2 AS b WHERE
		q3c_join(a.ra, a.dec, b.ra, b.dec, a.err);

x) The positional cross-match of the tables with the ellipse error-area:
(for example if you want to find all the objects from one catalogue which lies
inside the bodies of the galaxies from the second catalogue)
The example: 

It is possible to do the join when the error area of each record of the 
catalogue is an ellipse. Then you can do the query like this

my_table# SELECT * FROM table1 AS a, table2 AS b WHERE
		q3c_ellipse_join(a.ra, a.dec, b.ra, b.dec, a.maj_ax
		a.axis_ratio, a.PA);

where axis_ratio is the column with axis ratio of the ellipses and PA is the 
column with the positional angles of them, and maj_ax is the column with major
axises of those ellipses.


x) The density estimation of your objects:

my_table# SELECT (q3c_ipix2ang(i))[1] as ra ,(q3c_ipix2ang(i))[2] as dec ,c,
				q3c_pixarea(i,25) as area from 
					(select q3c_ipixcenter(ra,dec, 25) as i, count(*) as c from
						q3c group by i) as x;


	returns the ra,dec of the Q3C pixel center, number of objects within a pixel, and 
	a pixel area.

